# 1.	Написати програму, яка обробляє дані про співробітників підприємства.
# У програмі визначити клас Employee, що описує деяких співробітників з погодинною оплатою.
# В класі забезпечити наявність наступних атрибутів даних: ідентифікатор, ім'я співробітника, погодинна ставка, посада.
# Описати в класі метод для розрахунку середньомісячної заробітної плати.
# Для «погодинних» формула для розрахунку така: «середньомісячна заробітна платня = 20.8 * 8 * погодинну ставку»,.
# Програма повинна надавати функціональність:
# •	сортування співробітників по спадаючій середньомісячного заробітку.
# •	сортування співробітників по зростаючій середньомісячного заробітку.
# •	Виведення інформації про співробітників, у яких середньомісячний заробіток більше заданої суми.
# •	Пошук по співробітникам за їх унікальнім ідентифікатором.

# На іспиті буде схожа задача, але лише одна умова до неї!


# Оголошення класу
class Employee:
    # метод для ініціалізації екземпляру класа (об'єкту),(конструктор __init__).
    # В аргументи передаємо значення для змінних екземпляру.
    def __init__(self, employee_id, employee_name, rate, position):
        # заводимо змінні для екземпялру класу
        self.employee_id = employee_id      # ідентифікатор
        self.employee_name = employee_name  # ім'я співробітника
        self.rate = rate                    # погодинна ставка
        self.position = position            # посада
        self.m_salary = 0                   # середньомісячна ЗП. Нічого не передаємо, бо далі будемо її обраховувати

    # метод екземпляру (про це свідчить змінна self в аргументах методу)
    # метод обраховує середньомісячну ЗП за вказаною в умові формулою і повертає її
    def monthly_salary(self):
        self.m_salary = 20.8 * 8 * self.rate
        return self.m_salary

    # метод, який забезпечує коректне виведення в print() інформації про екземпляр
    def __repr__(self):
        return repr(f'{self.employee_id} {self.employee_name} works on {self.position}, \
has {self.rate} hourly rate and earns {self.m_salary}$ ')


# створення списку об'єктів робітників
# Викликається клас Employee, автоматично відпрацьовує метод __init__
# і в цей метод передаються  факутичні значення для формальних параметрів employee_id, employee_name, rate, position
employee_obj = [Employee(1292, 'Ann', 13.2, 'economic'),
                Employee(1422, 'Bob', 23.9, 'programmer'),
                Employee(2733, 'Mark', 23.1, 'lawyer'),
                Employee(9923, 'Tom', 13.3, 'economic')]

# визначення середньомісячної ЗП для кожного співробітника
# циклом проходимось по списку робітників і для кожного об'єкту
# викликаємо метод, що обраховує середньомісячну ЗП
for e in employee_obj:
    e.monthly_salary()

print(f'\n{1:-^100}\n Cортування співробітників по спадаючій середньомісячного заробітку \n')

# метод sorted приймає послідовність employee_obj яку буде сортувати
# в якості ключа сортування вказується лямбда-функція,
# яка повертає ЗП працівника.
# reverse означає направлення сортування. True - за спаданням.
sorted_employee = sorted(employee_obj, key=lambda employee: employee.m_salary, reverse=True)

# для зручного виведення "в стовпчик" відсортованої інформації про кожного співробітника
# map: приміняє функцію str до кожного елементу списку sorted_employee
# join: додає \n (перенос курсору на новий рядок) до кожного рядка в нашому списку
print('\n'.join(map(str, sorted_employee)))


print(f'\n{2:-^100}\n Сортування співробітників по зростаючій середньомісячного заробітку \n')

# все те ж саме, як і в попередньому, лише reverse=False
sorted_employee = sorted(employee_obj, key=lambda employee: employee.m_salary, reverse=False)
print('\n'.join(map(str, sorted_employee)))


print(f'\n{3:-^100}\n Виведення інформації про співробітників, у яких середньомісячний заробіток більше заданої суми\n')

# користувач задає сумму, з якою будемо порівнювати ЗП
amount = int(input('Input amount: '))

# циклом проходимось по списку робітників і для кожного об'єкту
# перевіряємо, якщо його ЗП: m_salary > amount, виводимо цей об'єкт
for e in employee_obj:
    if e.m_salary > amount:
        print(e)


print(f'\n{4:-^100}\n Пошук по співробітникам за їх унікальнім ідентифікатором \n')

# користувач вбиває ідентифікатор співробітника, за яким буде вестись пошук
search_id = int(input('Enter ID: '))

# флаг для перевірки чи буде співробітник із заданим ID
# якщо буде, то нижче в циклі змінемо флаг на True
flag = False

# циклом проходимось по списку робітників і для кожного об'єкту
# перевіряємо, якщо його ID дорівнює шуканому, виводимо цей об'єкт
# і змінюємо флаг на True
for e in employee_obj:
    if e.employee_id == search_id:
        print(e)
        flag = True

# перевіряємо флаг і якщо він не змінився, робим висновок, що
# співробітника за таким ID немає
# not flag = not False = True, а True - це умова для спрацювання оператора if
# якщо вище флаг змінився на True, то вийшло б: not flag = not True = False, тобто if не відпрацьовує
if not flag:
    print('Ops... \nNo employee with the specified ID')
